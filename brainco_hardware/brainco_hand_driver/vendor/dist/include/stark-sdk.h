#ifndef STARK_SDK_H
#define STARK_SDK_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

/// Built‑in gestures 1~6: open hand, fist, two‑finger pinch, three‑finger pinch,
/// side pinch, single‑finger point.
/// Revo1 supports up to 6 custom action sequences: IDs 10~15.
/// Revo2 supports up to 24 custom action sequences: IDs 7~30.
enum ActionSequenceId : uint8_t {
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_OPEN = 1,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_FIST = 2,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_TWO = 3,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_THREE = 4,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_SIDE = 5,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_POINT = 6,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE22 = 7,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE23 = 8,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE24 = 9,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE1 = 10,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE2 = 11,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE3 = 12,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE4 = 13,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE5 = 14,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE6 = 15,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE7 = 16,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE8 = 17,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE9 = 18,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE10 = 19,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE11 = 20,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE12 = 21,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE13 = 22,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE14 = 23,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE15 = 24,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE16 = 25,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE17 = 26,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE18 = 27,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE19 = 28,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE20 = 29,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE21 = 30,
};

enum ContactState : uint8_t {
  CONTACT_STATE_NO_CONTACT = 0,
  CONTACT_STATE_CONTACT = 1,
  CONTACT_STATE_CONTACT_SLIDING = 2,
};

enum EtherCATFoeType : uint8_t {
  ETHER_CAT_FOE_TYPE_WRIST = 1,
  ETHER_CAT_FOE_TYPE_CONTROL = 2,
};

enum FingerUnitMode : uint8_t {
  FINGER_UNIT_MODE_NORMALIZED = 0,
  FINGER_UNIT_MODE_PHYSICAL = 1,
};

enum ForceLevel : uint8_t {
  FORCE_LEVEL_SMALL = 1,
  FORCE_LEVEL_NORMAL = 2,
  FORCE_LEVEL_FULL = 3,
};

enum LedColor : uint8_t {
  LED_COLOR_UNCHANGED = 0,
  LED_COLOR_R = 1,
  LED_COLOR_G = 2,
  LED_COLOR_RG = 3,
  LED_COLOR_B = 4,
  LED_COLOR_RB = 5,
  LED_COLOR_GB = 6,
  LED_COLOR_RGB = 7,
};

enum LedMode : uint8_t {
  LED_MODE_NONE = 0,
  LED_MODE_SHUTDOWN = 1,
  LED_MODE_KEEP = 2,
  LED_MODE_BLINK = 3,
  LED_MODE_ONE_SHOT = 4,
  LED_MODE_BLINK0_5HZ = 5,
  LED_MODE_BLINK2_HZ = 6,
};

enum LogLevel : uint8_t {
  LOG_LEVEL_ERROR = 0,
  LOG_LEVEL_WARN = 1,
  LOG_LEVEL_INFO = 2,
  LOG_LEVEL_DEBUG = 3,
  LOG_LEVEL_TRACE = 4,
};

enum MotorState : uint8_t {
  MOTOR_STATE_IDLE = 0,
  MOTOR_STATE_RUNNING = 1,
  MOTOR_STATE_STALL = 2,
  MOTOR_STATE_TURBO = 3,
  MOTOR_STATE_UNKNOWN = 255,
};

enum PressState : uint8_t {
  PRESS_STATE_NONE = 0,
  PRESS_STATE_DOWN = 1,
  PRESS_STATE_UP = 2,
};

enum SkuType : uint8_t {
  SKU_TYPE_MEDIUM_RIGHT = 1,
  SKU_TYPE_MEDIUM_LEFT = 2,
  SKU_TYPE_SMALL_RIGHT = 3,
  SKU_TYPE_SMALL_LEFT = 4,
};

enum StarkFingerId : uint8_t {
  STARK_FINGER_ID_THUMB = 1,
  STARK_FINGER_ID_THUMB_AUX = 2,
  STARK_FINGER_ID_INDEX = 3,
  STARK_FINGER_ID_MIDDLE = 4,
  STARK_FINGER_ID_RING = 5,
  STARK_FINGER_ID_PINKY = 6,
};

enum StarkHardwareType : uint8_t {
  STARK_HARDWARE_TYPE_RS485_PROTOBUF = 0,
  STARK_HARDWARE_TYPE_REVO1_BASIC = 1,
  STARK_HARDWARE_TYPE_REVO1_TOUCH = 2,
  STARK_HARDWARE_TYPE_REVO2_BASIC = 3,
  STARK_HARDWARE_TYPE_REVO2_TOUCH = 4,
  STARK_HARDWARE_TYPE_REVO1_ADVANCED = 5,
};

enum StarkProtocolType : uint8_t {
  STARK_PROTOCOL_TYPE_MODBUS = 1,
  STARK_PROTOCOL_TYPE_CAN = 2,
  STARK_PROTOCOL_TYPE_CAN_FD = 3,
  STARK_PROTOCOL_TYPE_ETHER_CAT = 4,
  STARK_PROTOCOL_TYPE_PROTOBUF = 5,
};

enum TouchSensorStatus : uint8_t {
  TOUCH_SENSOR_STATUS_NORMAL = 0,
  TOUCH_SENSOR_STATUS_ABNORMAL = 1,
  TOUCH_SENSOR_STATUS_COMMUNICATION_ERROR = 2,
  TOUCH_SENSOR_STATUS_UNKNOWN = 255,
};

struct DeviceHandler;

/// Device configuration
struct DeviceConfig {
  StarkProtocolType protocol;
  const char *port_name;
  uint32_t baudrate;
  uint8_t slave_id;
};

/// Device information
/// sku_type: Device type, 1: right hand, 2: left hand
/// hardware_type: Hardware type
/// serial_number: Serial number
/// firmware_version: Firmware version
struct DeviceInfo {
  SkuType sku_type;
  StarkHardwareType hardware_type;
  const char *serial_number;
  const char *firmware_version;
};

struct MotorStatusData {
  uint16_t positions[6];
  int16_t speeds[6];
  int16_t currents[6];
  uint8_t states[6];
};

struct TouchRawData {
  uint32_t thumb[7];
  uint32_t index[11];
  uint32_t middle[11];
  uint32_t ring[11];
  uint32_t pinky[7];
};

/// Tactile sensor data
/// 3D force values, self-capacitance, mutual-capacitance values, and sensor status.
/// Revo2 touch hand only has normal force, tangential force, tangential force
/// direction, and proximity; other fields are zero.
struct TouchFingerItem {
  uint16_t normal_force1;
  uint16_t normal_force2;
  uint16_t normal_force3;
  uint16_t tangential_force1;
  uint16_t tangential_force2;
  uint16_t tangential_force3;
  uint16_t tangential_direction1;
  uint16_t tangential_direction2;
  uint16_t tangential_direction3;
  uint32_t self_proximity1;
  uint32_t self_proximity2;
  uint32_t mutual_proximity;
  uint16_t status;
};

struct TouchFingerData {
  TouchFingerItem items[5];
};

struct TurboConfig {
  uint16_t interval;
  uint16_t duration;
};

struct LedInfo {
  LedColor color;
  LedMode mode;
};

struct ButtonPressEvent {
  int32_t timestamp;
  int32_t button_id;
  PressState press_state;
};

/// Tactile sensor data callback type.
/// Modbus async read/write result callback.
/// This callback processes results of asynchronous Modbus operations.
/// Return value: 0 on success, non‑zero on failure.
using ModbusOperationResultCallback = void(*)(uint8_t*, int, int, void*);

/// Modbus async read/write callback type.
/// Return value: 0 on success, non‑zero on failure.
using ModbusOperationCallback = int32_t(*)(const uint8_t *values,
                                           int len,
                                           ModbusOperationResultCallback callback,
                                           void *user_data);

/// Custom Modbus RX callback.
/// Return value: 0 on success, non‑zero on failure.
using ModbusRxCallback = int32_t(*)(uint8_t slave_id,
                                    uint16_t register_address,
                                    uint16_t *data_out,
                                    uint16_t count);

/// Custom Modbus TX callback.
/// Return value: 0 on success, non‑zero on failure.
using ModbusTxCallback = int32_t(*)(uint8_t slave_id,
                                    uint16_t register_address,
                                    const uint16_t *data,
                                    uint16_t count);

/// CAN/CANFD RX callback.
/// Note: `data_out` length must be at most 64.
/// Return value: 0 on success, non‑zero on failure.
using CanRxCallback = int32_t(*)(uint8_t slave_id,
                                 uint32_t *can_id_out,
                                 uint8_t *data_out,
                                 uintptr_t *data_len_out);

/// CAN/CANFD TX callback.
/// Return value: 0 on success, non‑zero on failure.
using CanTxCallback = int32_t(*)(uint8_t slave_id,
                                 uint32_t can_id,
                                 const uint8_t *data,
                                 uintptr_t data_len);

/// DFU state callback, `state` corresponds to `DfuState`.
using DfuStateCallback = void(*)(uint8_t slave_id, uint8_t state);

/// DFU progress callback.
using DfuProgressCallback = void(*)(uint8_t slave_id, float progress);

extern "C" {

/// Initialize SDK options.
/// protocol_type: Protocol type, default is Modbus.
/// log_level: Log level, default is Info.
void init_cfg(StarkProtocolType protocol_type, LogLevel log_level);

/// List all available Stark serial ports.
void list_available_ports();

/// Automatically detect a Stark device on a serial port.
/// It first tries Revo2 hands and then Revo1 hands.
/// port: Serial port name; when NULL, the function will auto‑detect ports.
/// quick: Whether to use quick detection. Default is true, which only checks
///        a subset of baudrates and slave IDs.
/// Returns a pointer to `DeviceConfig` (protocol, port, baudrate, slave ID);
/// call `free_device_config` to free the memory.
/// On failure, returns NULL.
/// Note: When `quick` is false, this function scans slave IDs in [1, 247],
///       which may take a long time.
DeviceConfig *auto_detect_device(const char *port, bool quick);

/// Automatically detect a Revo1 hand over Modbus.
/// port: Serial port name; when NULL, the function will auto‑detect ports.
/// quick: Whether to use quick detection. Default is true, which only checks
///        a subset of baudrates and slave IDs.
/// Returns a pointer to `DeviceConfig` (protocol, port, baudrate, slave ID);
/// call `free_device_config` to free the memory.
/// On failure, returns NULL.
/// Note: When `quick` is false, this function scans slave IDs in [1, 247],
///       which may take a long time.
DeviceConfig *auto_detect_modbus_revo1(const char *port, bool quick);

/// Automatically detect a Revo2 hand over Modbus.
/// port: Serial port name; when NULL, the function will auto‑detect ports.
/// quick: Whether to use quick detection. Default is true, which only checks
///        a subset of baudrates and slave IDs.
/// Returns a pointer to `DeviceConfig` (protocol, port, baudrate, slave ID);
/// call `free_device_config` to free the memory.
/// On failure, returns NULL.
/// Note: When `quick` is false, this function scans slave IDs in [1, 247],
///       which may take a long time.
DeviceConfig *auto_detect_modbus_revo2(const char *port, bool quick);

/// Open a serial port.
/// port: Serial port name, for example "/dev/ttyUSB0" or "COM1".
/// baudrate: Baud rate, one of 115200, 57600, 19200, 460800.
///           Revo1 default is 115200; Revo2 default is 460800, and Revo2 also
///           supports 1M, 2M, 5M.
/// Returns a pointer to `DeviceHandler`; call `modbus_close` to free it.
/// On failure, returns NULL.
DeviceHandler *modbus_open(const char *port, uint32_t baudrate);

/// 关闭串口
void modbus_close(DeviceHandler *handle);

/// @brief  Create a new `DeviceHandler`.
/// @return Pointer to the newly created `DeviceHandler`. Call
///         `free_device_handler` to release it.
DeviceHandler *create_device_handler();

/// @brief  Free a `DeviceHandler`.
/// @param handle  Pointer to `DeviceHandler`.
void free_device_handler(DeviceHandler *handle);

/// @brief  Create a new CANFD `DeviceHandler`.
/// @param master_id Master device ID, range 1~255.
/// @return Pointer to the newly created `DeviceHandler`. Call
///         `free_device_handler` to release it.
DeviceHandler *canfd_init(uint8_t master_id);

/// Open the EtherCAT igH Master.
DeviceHandler *ethercat_open_master(uint32_t master_pos);

/// Close the EtherCAT igH Master.
void ethercat_close(DeviceHandler *handle);

/// Configure SDO for an EtherCAT slave device.
void ethercat_setup_sdo(DeviceHandler *handle, uint16_t slave_pos);

void ethercat_reserve_master(DeviceHandler *handle);

/// Start EtherCAT cyclic loop with PDO communication (control & read).
/// dc_assign_activate: DC flags; 0x0000 means DC is not enabled.
/// sync0_cycle_time: SYNC0 cycle time in nanoseconds. The loop period matches
///                   SYNC0 cycle time.
/// sync0_shift_time: SYNC0 phase shift in nanoseconds.
/// sync1_cycle_time: SYNC1 cycle time in nanoseconds.
/// sync1_shift_time: SYNC1 phase shift in nanoseconds.
void ethercat_start_loop(DeviceHandler *handle,
                         const uint16_t *slave_positions,
                         int count,
                         uint16_t dc_assign_activate,
                         uint32_t sync0_cycle_time,
                         int32_t sync0_shift_time,
                         uint32_t sync1_cycle_time,
                         int32_t sync1_shift_time);

/// Stop the EtherCAT cyclic loop.
void ethercat_stop_loop(DeviceHandler *handle);

/// EtherCAT DFU: upgrade firmware via FoE protocol.
/// slave_pos: Slave position.
/// dfu_type: DFU type, Control or Wrist.
/// file_path: Firmware file path.
void ethercat_start_dfu(DeviceHandler *handle,
                        uint16_t slave_pos,
                        EtherCATFoeType dfu_type,
                        const char *file_path);

/// Get device information.
/// Returns a pointer to `DeviceInfo`; you must call `free_device_info` to free
/// it. Returns NULL on failure.
DeviceInfo *stark_get_device_info(DeviceHandler *handle, uint8_t slave_id);

/// Determine whether the hand is a touch hand by serial number.
bool is_touch_hand_by_sn(const char *sn_ptr);

/// Determine whether the hand is Revo2 by serial number.
bool is_revo2_hand_by_sn(const char *sn_ptr);

/// Get RS485 serial baud rate.
/// Valid values: 115200, 57600, 19200, 460800.
uint32_t stark_get_rs485_baudrate(DeviceHandler *handle, uint8_t slave_id);

/// Set RS485 serial baud rate.
/// Supported values: 115200, 57600, 19200, 460800.
void stark_set_rs485_baudrate(DeviceHandler *handle, uint8_t slave_id, uint32_t baudrate);

/// Get CANFD baud rate.
/// Supported values: 1M, 2M, 4M, 5M.
uint32_t stark_get_canfd_baudrate(DeviceHandler *handle, uint8_t slave_id);

/// Set CANFD baud rate.
/// Supported values: 1M, 2M, 4M, 5M.
void stark_set_canfd_baudrate(DeviceHandler *handle, uint8_t slave_id, uint32_t baudrate);

/// Set device slave ID.
/// Default is 1, valid range 1~247; 0 is the broadcast address.
/// Revo1 default ID is 1; Revo2 default left/right IDs are 0x7E and 0x7F.
/// When controlling multiple devices on the same bus, assign different IDs,
/// e.g. left=1, right=2.
/// Using broadcast ID 0 controls all devices on the bus; per Modbus spec,
/// broadcast commands do not receive responses.
void stark_set_slave_id(DeviceHandler *handle, uint8_t slave_id, uint8_t new_id);

/// Deprecated.
/// Set force level (only supported on standard Revo1).
void stark_set_force_level(DeviceHandler *handle, uint8_t slave_id, ForceLevel level);

/// Deprecated.
/// Get force level (only supported on standard Revo1).
uint8_t stark_get_force_level(DeviceHandler *handle, uint8_t slave_id);

/// Get device supply voltage in mV.
uint16_t stark_get_voltage(DeviceHandler *handle, uint8_t slave_id);

/// Get LED enabled state.
bool get_led_enabled(DeviceHandler *handle, uint8_t slave_id);

/// Get buzzer enabled state.
bool get_buzzer_enabled(DeviceHandler *handle, uint8_t slave_id);

/// Get vibration enabled state.
bool get_vibration_enabled(DeviceHandler *handle, uint8_t slave_id);

/// Set LED enabled state.
void set_led_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// Set buzzer enabled state.
void set_buzzer_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// Set vibration enabled state.
void set_vibration_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// Configure unit mode and finger parameters for Revo2.
/// This setting is reset after power‑cycle.
/// Parameter ranges are documented here:
/// https://brainco.yuque.com/tykrbo/hws0nr/pynh5qnmfa1bgamc
/// Sets the control unit mode:
/// normalized mode or physical‑quantity mode.
void stark_set_finger_unit_mode(DeviceHandler *handle, uint8_t slave_id, FingerUnitMode mode);

/// Get the current control unit mode.
/// Returns `FingerUnitMode`; on failure returns `FingerUnitMode::Normalized`.
FingerUnitMode stark_get_finger_unit_mode(DeviceHandler *handle, uint8_t slave_id);

/// Set maximum angle for a finger.
/// max_pos: Maximum angle value; default is 60 87 84 84 84 84.
void stark_set_finger_max_position(DeviceHandler *handle,
                                   uint8_t slave_id,
                                   StarkFingerId finger_id,
                                   uint16_t max_pos);

/// Set minimum angle for a finger.
/// min_pos: Minimum angle in degrees; default is 0 0 0 0 0 0.
void stark_set_finger_min_position(DeviceHandler *handle,
                                   uint8_t slave_id,
                                   StarkFingerId finger_id,
                                   uint16_t min_pos);

/// Set maximum speed for a finger.
/// max_speed: Maximum speed in °/s; default is 145 150 130 130 130 130.
void stark_set_finger_max_speed(DeviceHandler *handle,
                                uint8_t slave_id,
                                StarkFingerId finger_id,
                                uint16_t max_speed);

/// Set maximum current for a finger.
/// max_current: Maximum current in mA; default is 1000.
void stark_set_finger_max_current(DeviceHandler *handle,
                                  uint8_t slave_id,
                                  StarkFingerId finger_id,
                                  uint16_t max_current);

/// Set protection current for a finger.
/// protected_current: Protection current in mA, range 100~1500, default
///                    500 500 500 500 500 500.
void stark_set_finger_protected_current(DeviceHandler *handle,
                                        uint8_t slave_id,
                                        StarkFingerId finger_id,
                                        uint16_t protected_current);

/// Read maximum angle for a finger.
/// Returns 0 on failure.
uint16_t stark_get_finger_max_position(DeviceHandler *handle,
                                       uint8_t slave_id,
                                       StarkFingerId finger_id);

/// Read minimum angle for a finger.
/// min_pos: Minimum angle in degrees; default is 0 0 0 0 0 0.
uint16_t stark_get_finger_min_position(DeviceHandler *handle,
                                       uint8_t slave_id,
                                       StarkFingerId finger_id);

/// Read maximum speed for a finger.
/// max_speed: Maximum speed in °/s; default is 145 150 130 130 130 130.
/// Returns 0 on failure.
uint16_t stark_get_finger_max_speed(DeviceHandler *handle,
                                    uint8_t slave_id,
                                    StarkFingerId finger_id);

/// Read maximum current for a finger.
/// max_current: Maximum current in mA; default is 1000.
/// Returns 0 on failure.
uint16_t stark_get_finger_max_current(DeviceHandler *handle,
                                      uint8_t slave_id,
                                      StarkFingerId finger_id);

/// Read protection current for a finger.
/// protected_current: Protection current in mA, range 100~1500, default
///                    500 500 500 500 500 500.
/// Returns 0 on failure.
uint16_t stark_get_finger_protected_current(DeviceHandler *handle,
                                            uint8_t slave_id,
                                            StarkFingerId finger_id);

/// Configure thumb AUX lock current.
/// aux_lock_current: in mA, range 100~500, default 200.
/// Only supported on Revo2.
void stark_set_thumb_aux_lock_current(DeviceHandler *handle,
                                      uint8_t slave_id,
                                      uint16_t aux_lock_current);

/// Read thumb AUX lock current.
/// Only supported on Revo2.
uint16_t stark_get_thumb_aux_lock_current(DeviceHandler *handle, uint8_t slave_id);

/// Set the position of a single finger.
///
/// # Parameters
/// - `position`: Position in the unified range **0~1000** (all devices,
///   all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - 0 means fully open, 1000 means fully closed.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_position(DeviceHandler *handle,
                               uint8_t slave_id,
                               StarkFingerId finger_id,
                               uint16_t position);

/// Set the speed of a single finger.
///
/// # Parameters
/// - `speed`: Speed in the unified range **-1000~+1000** (all devices,
///   all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - Positive: closing direction; negative: opening direction.
///   - 0: stop.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_speed(DeviceHandler *handle,
                            uint8_t slave_id,
                            StarkFingerId finger_id,
                            int16_t speed);

/// Set the current of a single finger.
///
/// # Parameters
/// - `current`: Current in the unified range **-1000~+1000** (all devices,
///   all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - Positive: closing direction; negative: opening direction.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_current(DeviceHandler *handle,
                              uint8_t slave_id,
                              StarkFingerId finger_id,
                              int16_t current);

/// Set the PWM of a single finger (Revo2 only).
///
/// # Parameters
/// - `pwm`: PWM value in the unified range **-1000~+1000** (all protocols).
///   - The SDK converts this internally based on protocol.
///   - Positive: closing direction; negative: opening direction.
///
/// # Unified range
/// For Modbus, CAN 2.0, and CANFD, the public API always uses the
/// -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_pwm(DeviceHandler *handle,
                          uint8_t slave_id,
                          StarkFingerId finger_id,
                          int16_t pwm);

/// Set position + desired time for a single finger (Revo2 only).
///
/// # Parameters
/// - `position`: Position in the unified range **0~1000** (all protocols).
/// - `millis`: Desired time in milliseconds, range 1~2000.
///
/// # Unified range
/// Position always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_position_with_millis(DeviceHandler *handle,
                                           uint8_t slave_id,
                                           StarkFingerId finger_id,
                                           uint16_t position,
                                           uint16_t millis);

/// Set position + desired speed for a single finger (Revo2 only).
///
/// # Parameters
/// - `position`: Position in the unified range **0~1000** (all protocols).
/// - `speed`: Speed value, range 1~1000.
///
/// # Unified range
/// Position always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_position_with_speed(DeviceHandler *handle,
                                          uint8_t slave_id,
                                          StarkFingerId finger_id,
                                          uint16_t position,
                                          uint16_t speed);

/// Set positions for multiple fingers.
///
/// # Parameters
/// - `positions`: Array of length 6, positions in the unified range
///   **0~1000** (all devices, all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - 0 means fully open, 1000 means fully closed.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_positions(DeviceHandler *handle,
                                uint8_t slave_id,
                                const uint16_t *positions,
                                uintptr_t len);

/// Set speeds for multiple fingers.
///
/// # Parameters
/// - `speeds`: Array of length 6, speeds in the unified range **-1000~+1000**
///   (all devices, all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - Positive: closing direction; negative: opening direction.
///   - 0: stop.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_speeds(DeviceHandler *handle,
                             uint8_t slave_id,
                             const int16_t *speeds,
                             uintptr_t len);

/// Set currents for multiple fingers.
///
/// # Parameters
/// - `currents`: Array of length 6, currents in the unified range
///   **-1000~+1000** (all devices, all protocols).
///   - The SDK converts this internally based on device type and protocol.
///   - Positive: closing direction; negative: opening direction.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the public
/// API always uses the -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_currents(DeviceHandler *handle,
                               uint8_t slave_id,
                               const int16_t *currents,
                               uintptr_t len);

/// Set PWM values for multiple fingers (Revo2 only).
///
/// # Parameters
/// - `pwms`: Array of length 6, PWM values in the unified range
///   **-1000~+1000** (all protocols).
///   - The SDK converts this internally based on protocol.
///   - Positive: closing direction; negative: opening direction.
///
/// # Unified range
/// For Modbus, CAN 2.0, and CANFD, the public API always uses the
/// -1000~+1000 range; the SDK handles conversion internally.
void stark_set_finger_pwms(DeviceHandler *handle,
                           uint8_t slave_id,
                           const int16_t *pwms,
                           uintptr_t len);

/// Set positions + desired times for multiple fingers (Revo2 only).
///
/// # Parameters
/// - `positions`: Array of length 6, positions in the unified range
///   **0~1000** (all protocols).
/// - `millis`: Array of length 6, desired times in milliseconds, range 1~2000.
///
/// # Unified range
/// Position always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_positions_and_durations(DeviceHandler *handle,
                                              uint8_t slave_id,
                                              const uint16_t *positions,
                                              const uint16_t *millis,
                                              uintptr_t len);

/// Set positions + desired speeds for multiple fingers (Revo2 only).
///
/// # Parameters
/// - `positions`: Array of length 6, positions in the unified range
///   **0~1000** (all protocols).
/// - `speeds`: Array of length 6, speeds in the range 1~1000.
///
/// # Unified range
/// Position always uses the 0~1000 range; the SDK handles conversion internally.
void stark_set_finger_positions_and_speeds(DeviceHandler *handle,
                                           uint8_t slave_id,
                                           const uint16_t *positions,
                                           const uint16_t *speeds,
                                           uintptr_t len);

/// Get finger motor status.
///
/// # Return value
/// Returns a pointer to `MotorStatusData`, which contains:
/// - `positions`: Position array, unified range **0~1000** (all devices,
///   all protocols).
/// - `speeds`: Speed array, unified range **-1000~+1000** (all devices,
///   all protocols).
/// - `currents`: Current array, unified range **-1000~+1000** (all devices,
///   all protocols).
/// - `states`: Motor state array.
///
/// # Unified range
/// For both Revo1 and Revo2, and for Modbus, CAN 2.0, and CANFD, the returned
/// data is always converted to the unified ranges above; the SDK handles
/// conversion internally.
///
/// # Memory management
/// You must call `free_motor_status_data` to free the result.
/// Returns NULL on failure.
MotorStatusData *stark_get_motor_status(DeviceHandler *handle, uint8_t slave_id);

/// Run an action sequence.
/// action_id: Action sequence ID.
void stark_run_action_sequence(DeviceHandler *handle, uint8_t slave_id, ActionSequenceId action_id);

/// Transfer action sequences to the device.
///
/// This function sends multiple action sequences. Each sequence is represented
/// by a fixed‑length array of `u16` parameters.
///
/// - `slave_id`: Slave device ID.
/// - `is_revo2`: Whether the device is Revo2.
/// - `action_id`: ID that uniquely identifies the action sequence.
/// - `sequences`: Flattened parameter array containing multiple sequences.
///
/// For Revo1, each action sequence contains 20 `u16` elements:
///   - Sequence index (u16): index of the sequence in the queue.
///   - Duration (u16): execution time in milliseconds.
///   - Finger positions (6 × u16): values in range 0~100.
///   - Finger speeds   (6 × u16): values in range 0~100.
///   - Finger forces   (6 × u16): values in range 0~100.
///
/// Example sequence array:
/// [0, 2000, 0, 0, 100, 100, 100, 100, 10, 20, 30, 40, 50, 60, 5, 10, 15, 20, 25, 30]
///
/// Meaning:
/// - `0`: sequence index.
/// - `2000`: duration in milliseconds.
/// - `0, 0, 100, 100, 100, 100`: 6 finger positions.
/// - `10, 20, 30, 40, 50, 60`: 6 finger speeds.
/// - `5, 10, 15, 20, 25, 30`: 6 finger forces.
///
/// For Revo2, each action sequence contains 27 `u16` elements:
///   - Sequence index (u16): index of the sequence in the queue.
///   - Duration (u16): execution time in milliseconds.
///   - Control mode (u16): 1=position+time, 2=position+speed,
///                         3=current, 4=speed.
///   - Finger positions (6 × u16): physical angle in degrees; 65535 (0xFFFF)
///     means keep current angle.
///   - Finger speeds   (6 × u16): physical rotational speed in °/s.
///   - Finger currents (6 × u16): physical current in mA.
///
/// - `len`: Number of sequences, i.e. number of rows in the flattened array.
///
/// # Parameters
/// - `action_id`: Action sequence ID.
/// - `sequences`: Pointer to the flattened sequence array.
/// - `len`: Number of sequences.
///
/// # Error handling
/// - If `handle` or `sequences` is NULL, the function returns immediately.
/// - If `len` exceeds the maximum allowed steps (Revo1: 32, Revo2: 8), a
///   warning is logged and the function returns.
void stark_set_action_sequence(DeviceHandler *handle,
                               uint8_t slave_id,
                               bool is_revo2,
                               ActionSequenceId action_id,
                               const uint16_t *sequences,
                               uintptr_t len);

/// Enable tactile sensors.
/// bits: Bitmask of sensors to enable, range 0~31.
/// For example: 0b00000001 enables only the thumb sensor.
void stark_enable_touch_sensor(DeviceHandler *handle, uint8_t slave_id, uint8_t bits);

/// Get raw channel data from the tactile sensors.
/// Returns a pointer to `TouchRawData`; call `free_touch_raw_data` to free it.
/// Returns NULL on failure.
TouchRawData *stark_get_touch_raw_data(DeviceHandler *handle, uint8_t slave_id);

/// Read 3D force, proximity and status for a single finger.
/// Returns a pointer to `TouchFingerItem`.
/// index: 0~4 for thumb, index, middle, ring, pinky.
/// Call `free_touch_finger_item` to free the result. Returns NULL on failure.
TouchFingerItem *stark_get_single_touch_status(DeviceHandler *handle,
                                               uint8_t slave_id,
                                               uint8_t index);

/// Read 3D force, proximity and status for all five fingers.
/// Returns a pointer to `TouchFingerData` containing all fingers.
/// Call `free_touch_finger_data` to free the result. Returns NULL on failure.
TouchFingerData *stark_get_touch_status(DeviceHandler *handle, uint8_t slave_id);

/// Reset tactile sensor measurement channels.
/// Try to keep the fingers unloaded (no force) when executing this command.
/// bits: Bitmask of sensors to reset, range 0~31.
/// For example: 0b00000001 resets the first sensor.
void stark_reset_touch_sensor(DeviceHandler *handle, uint8_t slave_id, uint8_t bits);

/// Calibrate tactile sensor parameters.
/// bits: Bitmask of sensors to calibrate, range 0~31.
/// For example: 0b00000001 calibrates the first sensor.
/// Use this when 3D force values are non‑zero in idle state.
/// https://www.brainco-hz.com/docs/revolimb-hand/protocol/stark_protocol_touch.html#_5-3-%E5%8F%82%E6%95%B0%E6%A0%A1%E5%87%864105
void stark_calibrate_touch_sensor(DeviceHandler *handle,
                                  uint8_t slave_id,
                                  uint8_t bits);

/// Query whether automatic position calibration on power‑up is enabled.
bool stark_get_auto_calibration(DeviceHandler *handle, uint8_t slave_id);

/// Enable or disable automatic position calibration on power‑up.
void stark_set_auto_calibration(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// Send manual position‑calibration command.
void stark_send_calibrate_position(DeviceHandler *handle, uint8_t slave_id);

/// Reset default gestures to factory settings.
void stark_reset_default_gesture(DeviceHandler *handle, uint8_t slave_id);

/// Reset all settings to factory defaults.
/// ● Default IDs: left hand → 0x7E (126); right hand → 0x7F (127).
/// ● RS485 baud rate: 460800 bps.
/// ● CAN FD baud rate: 5 Mbps.
void stark_reset_default_settings(DeviceHandler *handle, uint8_t slave_id);

/// Check whether Turbo mode is enabled.
/// When enabled, the hand will keep squeezing continuously.
bool stark_get_turbo_mode_enabled(DeviceHandler *handle, uint8_t slave_id);

/// Enable or disable Turbo mode.
void stark_set_turbo_mode_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// Get Turbo mode configuration.
/// Returns a pointer to `TurboConfig`; call `free_turbo_config` to free it.
/// Returns NULL on failure.
TurboConfig *stark_get_turbo_config(DeviceHandler *handle, uint8_t slave_id);

/// Get LED information.
/// Returns a pointer to `LedInfo`; call `free_led_info` to free it.
/// Returns NULL on failure.
LedInfo *stark_get_led_info(DeviceHandler *handle, uint8_t slave_id);

/// Get button press event.
/// Returns a pointer to `ButtonPressEvent`; call `free_button_event` to free it.
/// Returns NULL on failure.
ButtonPressEvent *stark_get_button_event(DeviceHandler *handle, uint8_t slave_id);

/// Start the DFU (Device Firmware Update) process.
/// - `handle`: Device handler pointer.
/// - `slave_id`: Slave device ID.
/// - `dfu_file_path`: DFU file path, as a C string.
/// - `wait_secs`: Timeout for entering DFU mode, in seconds (default 5).
void start_dfu(DeviceHandler *handle,
               uint8_t slave_id,
               const char *dfu_file_path,
               uintptr_t wait_secs);

/// Stop the DFU process.
/// - `slave_id`: Slave device ID.
/// This stops an ongoing DFU session.
/// Note: If DFU has not started or has already completed, this function has no effect.
void stop_dfu(uint8_t slave_id);

void free_device_config(DeviceConfig *config);

void free_device_info(DeviceInfo *info);

void free_motor_status_data(MotorStatusData *data);

void free_touch_raw_data(TouchRawData *data);

void free_touch_finger_data(TouchFingerData *status);

void free_touch_finger_item(TouchFingerItem *item);

void free_turbo_config(TurboConfig *config);

void free_led_info(LedInfo *info);

void free_button_event(ButtonPressEvent *event);

void free_string(const char *s);

/// Set Modbus async read/write callback.
void set_modbus_operation_callback(ModbusOperationCallback cb);

/// Set Modbus read callback for input registers.
void set_modbus_read_input_callback(ModbusRxCallback cb);

/// Set Modbus read callback for holding registers.
void set_modbus_read_holding_callback(ModbusRxCallback cb);

/// Set Modbus write callback.
void set_modbus_write_callback(ModbusTxCallback cb);

/// Set CAN/CANFD RX callback.
void set_can_rx_callback(CanRxCallback cb);

/// Set CAN/CANFD TX callback.
void set_can_tx_callback(CanTxCallback cb);

/// Set DFU state callback.
void set_dfu_state_callback(DfuStateCallback cb);

/// Set DFU progress callback.
void set_dfu_progress_callback(DfuProgressCallback cb);

}  // extern "C"

#endif  // STARK_SDK_H
